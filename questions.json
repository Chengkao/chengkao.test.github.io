[
  {
    "id": 1,
    "q": "下列哪一項最接近「機器語言」的特性？",
    "options": [
      "使用助憶符",
      "英文字撰寫程式",
      "全由0與1組成",
      "具可攜性"
    ]
  },
  {
    "id": 2,
    "q": "組合語言與機器語言最大差異為何？",
    "options": [
      "可跨平台",
      "使用助憶符",
      "不可流程控制",
      "由編譯器執行"
    ]
  },
  {
    "id": 3,
    "q": "高階程式語言最大的優點之一是？",
    "options": [
      "與硬體密切對應",
      "可讀性高",
      "指令集與CPU一致",
      "不需編譯"
    ]
  },
  {
    "id": 4,
    "q": "高階語言具有可攜性的原因是？",
    "options": [
      "同一家公司制定",
      "可直接控制硬體",
      "與CPU指令無強烈相依",
      "不需作業系統"
    ]
  },
  {
    "id": 5,
    "q": "編譯與直譯的共同目的為？",
    "options": [
      "設計CPU指令",
      "轉為電腦能執行內容",
      "增加安全性",
      "提供物件導向"
    ]
  },
  {
    "id": 6,
    "q": "FORTRAN語言主要應用於哪一領域？",
    "options": [
      "商業報表",
      "科學與工程計算",
      "網頁互動",
      "App開發"
    ]
  },
  {
    "id": 7,
    "q": "LISP特別適合用在AI領域的原因是？",
    "options": [
      "數值運算效率高",
      "能直接控制硬體",
      "符號運算能力強",
      "與所有語言完全相容"
    ]
  },
  {
    "id": 8,
    "q": "COBOL最初設計的主要用途為？",
    "options": [
      "科學運算",
      "低階硬體控制",
      "商業資料處理",
      "AI推論"
    ]
  },
  {
    "id": 9,
    "q": "BASIC在早期個人電腦廣泛使用的原因之一為？",
    "options": [
      "語法非常複雜",
      "DOS內建QBASIC",
      "必須使用大型主機",
      "完全不需編譯"
    ]
  },
  {
    "id": 10,
    "q": "Pascal最被推崇的特性為？",
    "options": [
      "可任意修改CPU指令",
      "支援規則推論",
      "結構化清楚且可讀性高",
      "自動記憶體管理"
    ]
  },
  {
    "id": 11,
    "q": "C語言同時具有高階與低階特色的原因為？",
    "options": [
      "完全以直譯方式執行",
      "可操作記憶體位址與暫存器",
      "無法跨平台",
      "具完整物件導向機制"
    ]
  },
  {
    "id": 12,
    "q": "PROLOG最典型的應用領域為？",
    "options": [
      "遊戲引擎開發",
      "邏輯推論與專家系統",
      "行動裝置App",
      "網頁前端互動"
    ]
  },
  {
    "id": 13,
    "q": "ADA語言是由哪一單位主導設計？",
    "options": [
      "IBM",
      "MIT",
      "美國國防部",
      "Google"
    ]
  },
  {
    "id": 14,
    "q": "C++與C語言的關係為何？",
    "options": [
      "C由C++改良而成",
      "C是C++的子集合",
      "兩者語法完全不同",
      "C++是純直譯語言"
    ]
  },
  {
    "id": 15,
    "q": "在物件導向中，「封裝」主要是指？",
    "options": [
      "自動將程式轉成機器碼",
      "將資料與操作資料的方法綁在一起",
      "將多種語言合併在同一檔案",
      "將演算法全部加密"
    ]
  },
  {
    "id": 16,
    "q": "Java最具代表性的技術優勢之一為？",
    "options": [
      "完全無需編譯",
      "速度永遠比C++快",
      "跨平台能力強",
      "只能用在手機程式"
    ]
  },
  {
    "id": 17,
    "q": "JavaScript主要扮演的角色是？",
    "options": [
      "作業系統核心程式",
      "伺服器端資料庫語言",
      "前端互動與事件處理",
      "專門執行AI模型"
    ]
  },
  {
    "id": 18,
    "q": "ASP.NET相較於早期ASP最大的改進是？",
    "options": [
      "所有程式碼寫在同一個HTML檔內",
      "將HTML與Script區分、較易撰寫與除錯",
      "只能做矩陣計算",
      "完全取代所有Web技術"
    ]
  },
  {
    "id": 19,
    "q": "Swift語言其中一個設計目標為？",
    "options": [
      "完全相容FORTRAN",
      "取代Objective-C並讓iOS開發更安全",
      "只能用在後端伺服器",
      "只適合低階硬體控制"
    ]
  },
  {
    "id": 20,
    "q": "Kotlin在Android開發上受到歡迎的主因為？",
    "options": [
      "與Java標準函式庫與生態相容",
      "僅能直譯執行",
      "由國防部主導開發",
      "不支援物件導向"
    ]
  },
  {
    "id": 21,
    "q": "下列何者為典型的程序式程式設計語言？",
    "options": [
      "C",
      "Java",
      "Prolog",
      "JavaScript"
    ]
  },
  {
    "id": 22,
    "q": "物件導向中的「多型」主要意涵為？",
    "options": [
      "多語言可互相呼叫",
      "相同介面可有不同實作",
      "同一程式可多次編譯",
      "同一變數可同時儲存多種型態"
    ]
  },
  {
    "id": 23,
    "q": "Python成為AI主流語言的原因之一是？",
    "options": [
      "是所有語言中執行速度最快",
      "擁有大量開源套件且語法簡潔",
      "只能做硬體控制",
      "僅能在Linux系統執行"
    ]
  },
  {
    "id": 24,
    "q": "新世代程式語言發展趨勢中，下列何者正確？",
    "options": [
      "全部改回低階語言",
      "所有語言都改為直譯",
      "AI輔助開發如Copilot與ChatGPT",
      "停止開發雲端相關語言"
    ]
  },
  {
    "id": 25,
    "q": "關於程式語言演進的核心變化，下列何者最適切？",
    "options": [
      "完全由硬體規格決定語言設計",
      "從機器導向→結構導向→物件導向→AI協作",
      "越新的語言語法一定更複雜",
      "新語言都不需要編譯"
    ]
  },
  {
    "id": 26,
    "q": "HBF 的主要應用市場為何？",
    "options": [
      "AI 訓練",
      "AI 推理",
      "資料中心備份",
      "手機遊戲"
    ]
  },
  {
    "id": 27,
    "q": "HBM 在 AI 應用中的一大缺點是什麼？",
    "options": [
      "容量過大",
      "寫入太慢",
      "成本極高",
      "不支援並行運算"
    ]
  },
  {
    "id": 28,
    "q": "NAND 相較於 DRAM 的最大缺點為何？",
    "options": [
      "成本較高",
      "容量較低",
      "耗電量較大",
      "讀寫延遲約慢上千倍"
    ]
  },
  {
    "id": 29,
    "q": "SanDisk 推出 HBF 的核心目的為何？",
    "options": [
      "以便宜 NAND 打入 AI 記憶體市場",
      "完全取代所有 GPU",
      "刻意縮短寫入壽命",
      "只用在 AI 訓練階段"
    ]
  },
  {
    "id": 30,
    "q": "HBM 最適合作為哪一種資料的儲存空間？",
    "options": [
      "全部模型參數",
      "歷史紀錄資料",
      "KV Cache 等需頻繁更新的資料",
      "使用者偏好紀錄"
    ]
  },
  {
    "id": 31,
    "q": "HBF 最適合存放哪一類 AI 模型參數？",
    "options": [
      "即時不停更新的權重",
      "大量僅在推理時被讀取的冷參數",
      "所有活躍專家參數",
      "GPU 的暫存暫列資料"
    ]
  },
  {
    "id": 32,
    "q": "在 MoE 模型中，大約有多少專家需要放在 HBM 這類高速記憶體？",
    "options": [
      "約 10%",
      "約 30%",
      "約 50%",
      "約 90%"
    ]
  },
  {
    "id": 33,
    "q": "為何 HBF 不適合直接用在 AI 訓練階段？",
    "options": [
      "速度太快而不穩定",
      "成本過低導致品質問題",
      "寫入壽命有限，頻繁更新會快速耗損",
      "無法與 GPU 連接"
    ]
  },
  {
    "id": 34,
    "q": "邊緣裝置偏好採用 HBF 的關鍵理由為何？",
    "options": [
      "耗電較高",
      "容量較小",
      "頻寬極低",
      "斷電後資料仍可保存"
    ]
  },
  {
    "id": 35,
    "q": "SK 海力士與 SanDisk 結盟推 HBF 的主要戰略考量是？",
    "options": [
      "同時掌握 HBM 與 HBF 兩種市場，避免被顛覆",
      "全面放棄 HBM 市場",
      "只專注於行動裝置記憶體",
      "刻意壓低 GPU 算力"
    ]
  },
  {
    "id": 36,
    "q": "HBF 面臨的主要商業風險為何？",
    "options": [
      "AI 模型無法縮小",
      "電力系統無法負荷",
      "可能重蹈 Optane 介於 DRAM 與 NAND 之間失敗的覆轍",
      "HBM 將在短期內完全被取代"
    ]
  },
  {
    "id": 37,
    "q": "SanDisk 規劃 HBF 量產商用的大致時間點為？",
    "options": [
      "約 2025 年",
      "約 2026 年",
      "約 2027 年",
      "約 2030 年之後"
    ]
  },
  {
    "id": 38,
    "q": "陣列在記憶體中的儲存特性為何？",
    "options": [
      "元素實體順序連續排列",
      "元素必須分散在不同區塊",
      "元素完全不連續",
      "每次執行位置都隨機改變"
    ]
  },
  {
    "id": 39,
    "q": "若 score[0] 位址為 start 且每個整數大小為 4 bytes，則 score[2] 的位址應為？",
    "options": [
      "start+4",
      "start+8",
      "start+12",
      "start+16"
    ]
  },
  {
    "id": 40,
    "q": "二維陣列 scores[1][3] 通常代表哪一個元素？",
    "options": [
      "第 1 列第 3 個元素",
      "第 2 列第 4 個元素",
      "第 2 列第 3 個元素",
      "第 3 列第 4 個元素"
    ]
  },
  {
    "id": 41,
    "q": "在 C 語言中，多維陣列預設採用哪一種記憶體存放方式？",
    "options": [
      "以列為主 row-major",
      "以欄為主 column-major",
      "以節點為主 node-major",
      "完全隨機儲存"
    ]
  },
  {
    "id": 42,
    "q": "在 FORTRAN 中，多維陣列預設採用哪一種記憶體存放方式？",
    "options": [
      "以列為主 row-major",
      "隨機存放",
      "以欄為主 column-major",
      "依指標順序排列"
    ]
  },
  {
    "id": 43,
    "q": "鏈結串列相較於陣列的一項缺點為何？",
    "options": [
      "速度一定較慢",
      "必須預先知道資料總數",
      "無法以註標直接隨機存取",
      "必須使用連續記憶體"
    ]
  },
  {
    "id": 44,
    "q": "一般單向鏈結串列每個節點通常包含哪些欄位？",
    "options": [
      "只有資料欄位",
      "資料與指向下一節點的指標",
      "只有位址資訊",
      "只有標號欄位"
    ]
  },
  {
    "id": 45,
    "q": "要取出鏈結串列中的某一節點資料，通常必須如何進行？",
    "options": [
      "依序沿著指標逐一走訪前面節點",
      "直接以公式計算位址",
      "利用索引直接跳到指定節點",
      "依照記憶體硬體自動搜尋"
    ]
  },
  {
    "id": 46,
    "q": "在將新節點插入鏈結串列前端時，新節點的 next 指標應先指向？",
    "options": [
      "原本的起始節點",
      "任意一個節點",
      "空指標",
      "自己本身"
    ]
  },
  {
    "id": 47,
    "q": "在鏈結串列前端插入新節點後，代表起點的 front 應該指向？",
    "options": [
      "原本最後一個節點",
      "第二個節點",
      "新建立的節點",
      "任意一個節點"
    ]
  },
  {
    "id": 48,
    "q": "鏈結串列的邏輯順序與實體記憶體順序之關係為何？",
    "options": [
      "永遠完全相同",
      "一定完全相反",
      "每個節點固定相鄰",
      "邏輯順序與實體順序不一定相同"
    ]
  },
  {
    "id": 49,
    "q": "下列何者最能說明陣列與鏈結串列在存取上的差異？",
    "options": [
      "陣列可以用註標直接隨機存取元素",
      "鏈結串列可以用註標直接存取",
      "陣列無法順序存取",
      "鏈結串列不需要指標即可運作"
    ]
  },
  {
    "id": 50,
    "q": "在二維陣列 scores 中，scores[0][1] 通常代表哪一個位置的資料？",
    "options": [
      "第 2 列第 1 個元素",
      "第 1 列第 2 個元素",
      "第 3 列第 1 個元素",
      "記憶體位址為 0x01 的元素"
    ]
  },
  {
    "id": 51,
    "q": "堆疊的主要特性為何？",
    "options": [
      "後進先出",
      "先進先出",
      "隨機存取",
      "依大小排序"
    ]
  },
  {
    "id": 52,
    "q": "top 初始值通常設定為？",
    "options": [
      "-1",
      "1",
      "空指標",
      "0"
    ]
  },
  {
    "id": 53,
    "q": "push 操作對 top 的影響為？",
    "options": [
      "增加",
      "減少",
      "不變",
      "重設"
    ]
  },
  {
    "id": 54,
    "q": "pop 操作回傳的是？",
    "options": [
      "top 的資料",
      "底部資料",
      "中間資料",
      "任意元素"
    ]
  },
  {
    "id": 55,
    "q": "佇列採用哪種存取方式？",
    "options": [
      "後進先出",
      "先進先出",
      "隨機取出",
      "依大小排序"
    ]
  },
  {
    "id": 56,
    "q": "佇列需要哪兩個指標？",
    "options": [
      "front、rear",
      "top、bottom",
      "L、R",
      "head、tail"
    ]
  },
  {
    "id": 57,
    "q": "put 操作會改變？",
    "options": [
      "front",
      "rear",
      "top",
      "index"
    ]
  },
  {
    "id": 58,
    "q": "get 操作依據？",
    "options": [
      "front",
      "rear",
      "top",
      "固定位置"
    ]
  },
  {
    "id": 59,
    "q": "環狀佇列避免溢位的技巧為？",
    "options": [
      "/",
      "*",
      "%",
      "//"
    ]
  },
  {
    "id": 60,
    "q": "環狀佇列大小 n 可存？",
    "options": [
      "n",
      "n-1",
      "n+2",
      "不限"
    ]
  },
  {
    "id": 61,
    "q": "front == rear 在環狀佇列表示？",
    "options": [
      "空佇列",
      "滿佇列",
      "錯誤",
      "中斷"
    ]
  },
  {
    "id": 62,
    "q": "滿佇列的判斷？",
    "options": [
      "front==rear",
      "rear 在 front 前一位",
      "top==-1",
      "index==0"
    ]
  },
  {
    "id": 63,
    "q": "樹根節點位於哪裡？",
    "options": [
      "最上層",
      "最下層",
      "任意",
      "右側"
    ]
  },
  {
    "id": 64,
    "q": "葉節點的特性為？",
    "options": [
      "至少一子節點",
      "無子節點",
      "必為根",
      "僅一子節點"
    ]
  },
  {
    "id": 65,
    "q": "內部節點的特徵是？",
    "options": [
      "無子節點",
      "僅一子節點",
      "至少一子節點",
      "必在第二層"
    ]
  },
  {
    "id": 66,
    "q": "樹結構不會出現？",
    "options": [
      "迴圈",
      "葉節點",
      "分支",
      "子節點"
    ]
  },
  {
    "id": 67,
    "q": "樹兩節點間路徑數為？",
    "options": [
      "多條",
      "兩條",
      "隨機",
      "唯一"
    ]
  },
  {
    "id": 68,
    "q": "樹的高度為？",
    "options": [
      "葉節點數",
      "節點深度平均值",
      "根到最深葉的最長路徑",
      "邊數"
    ]
  },
  {
    "id": 69,
    "q": "階層 level 定義為？",
    "options": [
      "節點數",
      "距根距離",
      "與葉差",
      "深度平方"
    ]
  },
  {
    "id": 70,
    "q": "祖先節點？",
    "options": [
      "所有子節點",
      "所有兄弟節點",
      "所有葉節點",
      "沿向上路徑節點"
    ]
  },
  {
    "id": 71,
    "q": "父節點為？",
    "options": [
      "最靠近子的祖先",
      "任意祖先",
      "葉節點",
      "根節點"
    ]
  },
  {
    "id": 72,
    "q": "子孫節點為？",
    "options": [
      "父節點",
      "往下所有可能節點",
      "葉節點",
      "兄弟節點"
    ]
  },
  {
    "id": 73,
    "q": "子節點為？",
    "options": [
      "父節點下一層",
      "根節點",
      "葉節點",
      "無法定義"
    ]
  },
  {
    "id": 74,
    "q": "二元樹限制為？",
    "options": [
      "最多兩子節點",
      "至少三子節點",
      "一子節點",
      "無限制"
    ]
  },
  {
    "id": 75,
    "q": "運算樹父節點通常是？",
    "options": [
      "運算元",
      "變數",
      "運算子",
      "常數"
    ]
  },
  {
    "id": 76,
    "q": "左子樹定義為？",
    "options": [
      "左子節點為根",
      "右子節點為根",
      "葉集合",
      "任意集合"
    ]
  },
  {
    "id": 77,
    "q": "右子樹定義為？",
    "options": [
      "左子節點集合",
      "右子節點為根",
      "所有分支",
      "全部葉"
    ]
  },
  {
    "id": 78,
    "q": "二元樹節點包含？",
    "options": [
      "三指標",
      "一指標",
      "兩指標",
      "零指標"
    ]
  },
  {
    "id": 79,
    "q": "前序法順序？",
    "options": [
      "父-左-右",
      "左-父-右",
      "左-右-父",
      "右-父-左"
    ]
  },
  {
    "id": 80,
    "q": "中序法順序？",
    "options": [
      "父-左-右",
      "左-父-右",
      "左-右-父",
      "右-父-左"
    ]
  },
  {
    "id": 81,
    "q": "後序法順序？",
    "options": [
      "父-左-右",
      "左-父-右",
      "左-右-父",
      "父-右-左"
    ]
  },
  {
    "id": 82,
    "q": "遞迴定義？",
    "options": [
      "自呼叫",
      "永不停止",
      "僅在排序用",
      "僅能計算整數"
    ]
  },
  {
    "id": 83,
    "q": "0! 的定義為？",
    "options": [
      "2",
      "5",
      "1",
      "無"
    ]
  },
  {
    "id": 84,
    "q": "階乘 n! 使用？",
    "options": [
      "n+1",
      "n-1",
      "n/2",
      "n*2"
    ]
  },
  {
    "id": 85,
    "q": "Google TPU 屬於？",
    "options": [
      "GPU",
      "CPU",
      "FPGA",
      "ASIC"
    ]
  },
  {
    "id": 86,
    "q": "GPU 特性？",
    "options": [
      "通用加速",
      "固定運算",
      "僅 AI 用",
      "僅繪圖"
    ]
  },
  {
    "id": 87,
    "q": "TPU 特性？",
    "options": [
      "通用性高",
      "專用 AI 加速",
      "僅圖形處理",
      "僅儲存資料"
    ]
  },
  {
    "id": 88,
    "q": "企業導入 TPU 原因？",
    "options": [
      "成本較高",
      "供應不足",
      "降低成本+風險",
      "不需學習"
    ]
  },
  {
    "id": 89,
    "q": "台積電角色？",
    "options": [
      "封裝",
      "皜祈岫",
      "軟體",
      "先進製程代工"
    ]
  },
  {
    "id": 90,
    "q": "佇列用途？",
    "options": [
      "排序",
      "排隊系統",
      "亂數",
      "子字串搜尋"
    ]
  },
  {
    "id": 91,
    "q": "堆疊用途？",
    "options": [
      "排序",
      "搜尋",
      "蝺函Ⅳ",
      "括號配對"
    ]
  },
  {
    "id": 92,
    "q": "環狀佇列優點？",
    "options": [
      "減少節點",
      "有效利用陣列",
      "增加速度",
      "減少硬體"
    ]
  },
  {
    "id": 93,
    "q": "樹可表示？",
    "options": [
      "線性資料",
      "陣列資料",
      "單一資料",
      "階層資料"
    ]
  },
  {
    "id": 94,
    "q": "根節點階層為？",
    "options": [
      "1",
      "2",
      "3",
      "無"
    ]
  },
  {
    "id": 95,
    "q": "葉節點位於？",
    "options": [
      "最上層",
      "最下層",
      "任意位置",
      "左子樹"
    ]
  },
  {
    "id": 96,
    "q": "父節點至少？",
    "options": [
      "無子節點",
      "一葉節點",
      "一子節點",
      "兩葉節點"
    ]
  },
  {
    "id": 97,
    "q": "後序法最後輸出？",
    "options": [
      "左子",
      "右子",
      "最深層",
      "父節點"
    ]
  },
  {
    "id": 98,
    "q": "樹走訪常使用？",
    "options": [
      "遞迴",
      "反覆迴圈",
      "堆疊",
      "佇列"
    ]
  },
  {
    "id": 99,
    "q": "二元樹可視為？",
    "options": [
      "單鏈結串列",
      "雙指標鏈結串列",
      "多重陣列",
      "平面圖"
    ]
  },
  {
    "id": 100,
    "q": "台積電在 TPU/GPU 中角色為？",
    "options": [
      "封裝廠",
      "IP 設計",
      "軟體供應",
      "先進製程代工"
    ]
  },
  {
    "id": 101,
    "q": "若 f(n)=3n²+5n，依漸近分析，其時間複雜度等級為？",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n²)",
      "O(2ⁿ)"
    ]
  },
  {
    "id": 102,
    "q": "下列何者屬於指數時間複雜度？",
    "options": [
      "n²",
      "n³",
      "2ⁿ",
      "n log n"
    ]
  },
  {
    "id": 103,
    "q": "若演算法 A 的時間複雜度為 O(n)，演算法 B 為 O(n²)，當 n 很大時通常哪一個效能較佳？",
    "options": [
      "演算法 A",
      "演算法 B",
      "兩者相同",
      "無法比較"
    ]
  },
  {
    "id": 104,
    "q": "在大 O 符號定義中，f(n)=O(g(n)) 的意義為？",
    "options": [
      "對所有 n 都有 f(n)=g(n)",
      "對足夠大的 n，f(n) 不會超過某常數倍的 g(n)",
      "f(n) 一定小於 g(n)",
      "g(n) 一定小於 f(n)"
    ]
  },
  {
    "id": 105,
    "q": "以下哪一個時間複雜度等級對大數據通常最不可行？",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n²)",
      "O(2ⁿ)"
    ]
  },
  {
    "id": 106,
    "q": "在漸近分析中，我們通常忽略常數係數的主要原因為？",
    "options": [
      "常數在數學上可以被消去",
      "當 n 很大時，常數倍差異遠小於等級差異",
      "電腦硬體會自動抵消常數影響",
      "只是教科書的習慣寫法"
    ]
  },
  {
    "id": 107,
    "q": "若計算機速度變快一百萬倍，對 10^n 時間複雜度演算法，可處理輸入大小 n 的增加量約為？",
    "options": [
      "大約只多 6",
      "大約多 2n",
      "可增加一百萬倍",
      "可以處理任意大的 n"
    ]
  },
  {
    "id": 108,
    "q": "下列函數成長階層由小到大的正確排序為何？",
    "options": [
      "n < \\log n < n² < 2ⁿ",
      "\\log n < n² < n < 2ⁿ",
      "\\log n < n < n² < 2ⁿ",
      "n < n² < 2ⁿ < \\log n"
    ]
  },
  {
    "id": 109,
    "q": "若演算法時間複雜度為 O(n³)，當輸入規模加倍時，執行時間大約會？",
    "options": [
      "增加約 8 倍",
      "增加約 2 倍",
      "增加約 3 倍",
      "幾乎不變"
    ]
  },
  {
    "id": 110,
    "q": "對同一問題，若演算法 C 的時間複雜度為 O(n \\log n)，演算法 D 為 O(n²)，當 n 由 1000 增加到 100 萬時，哪一個成長較慢？",
    "options": [
      "演算法 C",
      "演算法 D",
      "兩者成長相同",
      "需看常數大小才能判斷"
    ]
  },
  {
    "id": 111,
    "q": "令 f(n)=n²+100n，g(n)=0.01n³，下列敘述何者正確？",
    "options": [
      "f(n) 漸近成長速度比 g(n) 快",
      "兩者為同一等級",
      "g(n) 在漸近上成長較快",
      "兩者無法比較"
    ]
  },
  {
    "id": 112,
    "q": "在複雜度函數 f(n) 中，n 代表的意義最貼近下列哪一項？",
    "options": [
      "CPU 時脈頻率",
      "程式碼行數",
      "輸入、輸出或它們總和的大小",
      "硬碟容量"
    ]
  },
  {
    "id": 113,
    "q": "使用逐一比較法從 n 個數中找最大值，理論上需要幾次比較？",
    "options": [
      "n 次",
      "n-1 次",
      "\\log₂n 次",
      "2n-1 次"
    ]
  },
  {
    "id": 114,
    "q": "對 8 個數使用逐一比較法找最大值，總共需要幾次比較？",
    "options": [
      "8 次",
      "7 次",
      "6 次",
      "4 次"
    ]
  },
  {
    "id": 115,
    "q": "使用兩兩比較法從 n 個數（n 為 2 的整數次方）中找最大值，其比較次數為？",
    "options": [
      "n/2",
      "n-1",
      "n log₂n",
      "2n-3"
    ]
  },
  {
    "id": 116,
    "q": "求 n 個數的最大值與最小值時，作法 1（先找最大再在其餘中找最小）所需比較次數為？",
    "options": [
      "2n-3",
      "3n/2-2",
      "n+\\log₂n-2",
      "n(n-1)/2"
    ]
  },
  {
    "id": 117,
    "q": "求 n 個數的最大值與最小值時，作法 2（兩兩比較法）所需比較次數為？",
    "options": [
      "2n-3",
      "3n/2-2",
      "n+log₂n-2",
      "n²"
    ]
  },
  {
    "id": 118,
    "q": "對 8 個數同時找出最大值與最小值，作法 1 與作法 2 分別需 13 與 10 次比較，依此可推論何者正確？",
    "options": [
      "作法 1 比較次數較少",
      "作法 2 比較次數較少",
      "兩者比較次數完全相同",
      "必須視資料內容而定"
    ]
  },
  {
    "id": 119,
    "q": "從 n 個數中找最大值與第二大值時，兩兩比較法所需比較次數為？",
    "options": [
      "2n-3",
      "3n/2-2",
      "n+log₂n-2",
      "n²"
    ]
  },
  {
    "id": 120,
    "q": "在兩兩比較法中，為何找第二大值只需考慮『曾輸給最大值的那些數』？",
    "options": [
      "只有這些數曾直接與最大值比較過，其餘數一定不可能是第二大",
      "其他數都比最小值還小",
      "這樣可以保證比較次數相同",
      "因為演算法規定必須如此，沒有理由"
    ]
  },
  {
    "id": 121,
    "q": "對 8 個數利用兩兩比較法先找最大值，再在曾輸給最大值的元素中找第二大值，總比較次數為？",
    "options": [
      "7 次",
      "8 次",
      "10 次",
      "9 次"
    ]
  },
  {
    "id": 122,
    "q": "關於兩兩比較法，下列敘述何者正確？",
    "options": [
      "最大值只被比較一次",
      "最大值被比較次數約為 log₂n",
      "最小值被比較次數最多",
      "所有數被比較次數完全相同"
    ]
  },
  {
    "id": 123,
    "q": "選擇排序法每一趟的關鍵操作為？",
    "options": [
      "從未排序部分挑出最小數移到前端",
      "將新數插入已排序部分中的適當位置",
      "從後往前交換相鄰兩數",
      "選一個 pivot 將數列分成兩半"
    ]
  },
  {
    "id": 124,
    "q": "選擇排序法在 n 個數上，總比較次數約為？",
    "options": [
      "n-1",
      "n log₂n",
      "n(n-1)/2",
      "2ⁿ"
    ]
  },
  {
    "id": 125,
    "q": "就漸近時間複雜度而言，選擇排序法屬於？",
    "options": [
      "O(n)",
      "O(n \\log n)",
      "O(n²)",
      "O(2ⁿ)"
    ]
  },
  {
    "id": 126,
    "q": "插入排序法每次從未排序數列中取出的元素是？",
    "options": [
      "最後一個元素",
      "第一個元素",
      "最小的元素",
      "最大的元素"
    ]
  },
  {
    "id": 127,
    "q": "在改良的插入排序法中，若使用二元搜尋在已排序數列中尋找插入位置，其比較次數上界的成長等級約為？",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n²)",
      "O(2ⁿ)"
    ]
  },
  {
    "id": 128,
    "q": "插入排序法在何種情況下會產生 1+2+…+(n-1) 次移動，成長速率與 n² 成正比？",
    "options": [
      "原始數列已由小排到大",
      "原始數列為隨機順序",
      "原始數列由大排到小",
      "所有數值都相同"
    ]
  },
  {
    "id": 129,
    "q": "教材中提出前半段使用插入排序、後半段使用選擇排序的混合策略，其主要目的為？",
    "options": [
      "前半段已排序數列較短，插入排序搬移成本低；後半段未排序數列較短，選擇排序比較次數較少",
      "讓程式碼看起來較複雜",
      "把時間複雜度降到 O(n)",
      "避免使用遞迴"
    ]
  },
  {
    "id": 130,
    "q": "泡沫排序法每一趟掃描的效果為？",
    "options": [
      "將最大數移到最後面",
      "將最小數像泡沫一樣浮到最前面",
      "將中位數移到中央位置",
      "保證所有數都交換一次"
    ]
  },
  {
    "id": 131,
    "q": "泡沫排序法與選擇排序法的共同特性為？",
    "options": [
      "都屬於 O(n log n) 等級",
      "每一趟都會確定一個最小值並將其放到前端",
      "都需要額外 O(n) 儲存空間",
      "都必須使用遞迴實作"
    ]
  },
  {
    "id": 132,
    "q": "快速排序法的主要步驟中，下列哪一項描述最正確？",
    "options": [
      "每次將最大元素換到數列最前面",
      "每次都選擇中位數作為 pivot",
      "先將一個 pivot 放到正確位置，再對左右兩側子數列遞迴排序",
      "只要掃描一次陣列就能完成排序"
    ]
  },
  {
    "id": 133,
    "q": "在理想情況下（每次都將數列切成大小相近的兩半），快速排序法之平均比較次數的成長等級為？",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n²)",
      "O(2ⁿ)"
    ]
  },
  {
    "id": 134,
    "q": "若快速排序法每次選到的 pivot 都把數列切成一個長度為 1 與一個長度為 n-1 的子數列，其時間複雜度會接近？",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n²)",
      "O(2ⁿ)"
    ]
  },
  {
    "id": 135,
    "q": "在教材範例中，第一次以 16 為 pivot 做 partition 後，16 的狀態為何？",
    "options": [
      "已位於其最終排序位置，且左邊元素皆不大於 16、右邊元素皆不小於 16",
      "仍可能移到左邊或右邊",
      "一定會移到數列最左端",
      "一定會移到數列最右端"
    ]
  },
  {
    "id": 136,
    "q": "綜合使用插入排序與選擇排序的混合方法，其整體時間複雜度等級為？",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n²)",
      "O(2ⁿ)"
    ]
  },
  {
    "id": 137,
    "q": "循序搜尋法的主要缺點為何？",
    "options": [
      "必須先排序數列",
      "當數列很長時，每次搜尋平均要比對很多元素，效率較差",
      "無法找出目標元素的位置",
      "需要額外 O(n) 的儲存空間"
    ]
  },
  {
    "id": 138,
    "q": "二元搜尋法能正確運作的前提條件為？",
    "options": [
      "數列無重複值",
      "數列已依大小排序",
      "數列長度必須為 2 的整數次方",
      "數列元素都為正整數"
    ]
  },
  {
    "id": 139,
    "q": "若已排序數列長度為 2^{30}，大約需要幾次比較才能用二元搜尋法判斷某數是否在其中？",
    "options": [
      "30 次",
      "31 次",
      "60 次",
      "2³⁰ 次"
    ]
  },
  {
    "id": 140,
    "q": "對長度為 n 的已排序數列，二元搜尋法最壞情況比較次數約為？",
    "options": [
      "log₂n",
      "n",
      "n²",
      "√n"
    ]
  },
  {
    "id": 141,
    "q": "二元搜尋法每做一次比較，問題規模大致變成？",
    "options": [
      "原本的一半",
      "原本的三分之一",
      "固定減少 10",
      "幾乎不變"
    ]
  },
  {
    "id": 142,
    "q": "對尚未排序的數列若只需搜尋一次，較合理的作法為？",
    "options": [
      "先排序再做二元搜尋",
      "直接做循序搜尋",
      "先建立樹狀結構再搜尋",
      "先轉成雜湊表再搜尋"
    ]
  },
  {
    "id": 143,
    "q": "若需在同一份資料上重複做大量搜尋，下列哪個策略較佳？",
    "options": [
      "每次都做循序搜尋",
      "先排序，之後採二元搜尋",
      "每次搜尋前先隨機打亂數列",
      "逐次刪除已搜尋過的元素"
    ]
  },
  {
    "id": 144,
    "q": "教材中提到，下列哪一個是已證明『無法解答』的問題？",
    "options": [
      "旅行推銷員問題",
      "小偷背包問題",
      "判斷程式是否會停的問題",
      "二元搜尋問題"
    ]
  },
  {
    "id": 145,
    "q": "關於 NP-Complete 問題，下列哪一項是其主要特色？",
    "options": [
      "都有線性時間解法",
      "目前沒有已知的有效精確解法",
      "一定完全無解",
      "都可以在常數時間內完成"
    ]
  },
  {
    "id": 146,
    "q": "下列哪一個在教材中被提及為 NP-Complete 問題？",
    "options": [
      "二元搜尋法",
      "插入排序法",
      "旅行推銷員問題",
      "線性掃描"
    ]
  },
  {
    "id": 147,
    "q": "下列哪一個也被提及為 NP-Complete 問題？",
    "options": [
      "氣泡排序問題",
      "小偷背包問題",
      "最大值搜尋問題",
      "二元樹走訪問題"
    ]
  },
  {
    "id": 148,
    "q": "關於 NP-Complete 問題，下列敘述何者正確？",
    "options": [
      "只要找到其中一題的有效解法，其餘題目仍可能沒有",
      "只要有一題找到有效解法，其它所有 NP-Complete 問題也都有有效解法",
      "每一題最多只有一個解",
      "都不可能有近似解法"
    ]
  },
  {
    "id": 149,
    "q": "教材中提到，小偷背包問題與旅行推銷員問題之間，下列哪一項敘述正確？",
    "options": [
      "兩者精確解法與近似解法的難度完全相同",
      "兩者精確解法難度不同",
      "精確解法難度相同，但近似解法難度不同",
      "兩者都已有線性時間精確解法"
    ]
  },
  {
    "id": 150,
    "q": "對 NP-Complete 類型的問題，目前較常被期待的研究方向為何？",
    "options": [
      "證明所有問題都無法解決",
      "只尋找小規模例子的手算解答",
      "在有效率的時間內找到和最佳解答差不多的近似解",
      "避免研究這類問題"
    ]
  }
]